let scene, camera, renderer, cube;
let ws;
let clientId;
let peers = new Map();
let gltfLoader;

// Asset streaming state
let assetStreams = new Map(); // Track incoming asset streams

function initThreeJS() {
  const container = document.getElementById("canvas-container");

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);

  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000,
  );
  camera.position.z = 5;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // Initialize GLTFLoader
  gltfLoader = new THREE.GLTFLoader();

  const geometry = new THREE.BoxGeometry(2, 2, 2);
  const material = new THREE.MeshStandardMaterial({
    color: 0x4caf50,
    roughness: 0.5,
    metalness: 0.5,
  });
  cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);

  window.addEventListener("resize", onWindowResize);

  animate();
}

function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function initWebSocket() {
  const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
  ws = new WebSocket(`${protocol}//${window.location.host}`);

  ws.onopen = () => {
    console.log("WebSocket connected");
    updateStatus("ws-status", "Connected", "connected");
  };

  ws.onmessage = (event) => {
    // Handle binary data (asset chunks)
    if (event.data instanceof Blob) {
      event.data.arrayBuffer().then((buffer) => {
        handleAssetChunkData(buffer);
      });
    } else {
      // Handle JSON messages
      const data = JSON.parse(event.data);
      handleSignalingMessage(data);
    }
  };

  ws.onclose = () => {
    console.log("WebSocket disconnected");
    updateStatus("ws-status", "Disconnected", "disconnected");
  };

  ws.onerror = (error) => {
    console.error("WebSocket error:", error);
  };
}

function handleSignalingMessage(data) {
  switch (data.type) {
    case "welcome":
      clientId = data.id;
      document.getElementById("client-id").textContent = clientId.substring(
        0,
        8,
      );
      console.log("Client ID:", clientId);

      data.peers.forEach((peerId) => {
        createPeerConnection(peerId, true);
      });

      // Request an asset after connection
      setTimeout(() => requestAsset("cube", "high"), 1000);
      break;

    case "peer-connected":
      console.log("Peer connected:", data.peerId);
      break;

    case "peer-disconnected":
      console.log("Peer disconnected:", data.peerId);
      if (peers.has(data.peerId)) {
        peers.get(data.peerId).destroy();
        peers.delete(data.peerId);
        updatePeerCount();
      }
      break;

    case "signal":
      if (!peers.has(data.from)) {
        createPeerConnection(data.from, false);
      }
      peers.get(data.from).signal(data.signal);
      break;

    case "asset-start":
      handleAssetStart(data);
      break;

    case "asset-chunk":
      handleAssetChunkMetadata(data);
      break;

    case "asset-complete":
      handleAssetComplete(data);
      break;

    case "asset-error":
      console.error("Asset error:", data.error);
      updateStatus("asset-status", "Error", "disconnected");
      break;

    case "asset-list":
      console.log("Available assets:", data.assets);
      break;
  }
}

function createPeerConnection(peerId, initiator) {
  console.log(
    `Creating peer connection with ${peerId}, initiator: ${initiator}`,
  );

  const peer = new SimplePeer({
    initiator: initiator,
    trickle: true,
  });

  peer.on("signal", (signal) => {
    ws.send(
      JSON.stringify({
        type: "signal",
        signal: signal,
      }),
    );
  });

  peer.on("connect", () => {
    console.log(`WebRTC connected to peer ${peerId}`);
    updatePeerCount();

    sendBinaryData(peer);
  });

  peer.on("data", (data) => {
    console.log(`Received data from ${peerId}:`, data);
    handleBinaryData(data);
  });

  peer.on("close", () => {
    console.log(`Peer ${peerId} closed`);
    peers.delete(peerId);
    updatePeerCount();
  });

  peer.on("error", (err) => {
    console.error(`Peer ${peerId} error:`, err);
  });

  peers.set(peerId, peer);
}

function sendBinaryData(peer) {
  const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  console.log("Sending binary data:", testData);

  peer.send(testData);

  const array = new Float32Array([1.5, 2.5, 3.5, 4.5]);
  peer.send(array);

  updateStatus("binary-status", "Sent", "connected");
}

function handleBinaryData(data) {
  if (data instanceof ArrayBuffer) {
    const view = new Uint8Array(data);
    console.log("Received binary data (ArrayBuffer):", view);
    updateStatus("binary-status", "Received", "connected");
  } else if (data instanceof Uint8Array) {
    console.log("Received binary data (Uint8Array):", data);
    updateStatus("binary-status", "Received", "connected");
  } else {
    console.log("Received data:", data);
  }
}

function updatePeerCount() {
  document.getElementById("peer-count").textContent = peers.size;
}

function updateStatus(elementId, text, className) {
  const element = document.getElementById(elementId);
  element.textContent = text;
  element.className = className;
}

// Asset Streaming Functions

function requestAsset(assetId) {
  console.log("Requesting asset:", assetId);
  ws.send(
    JSON.stringify({
      type: "request-asset",
      assetId: assetId,
    }),
  );
  updateStatus("asset-status", "Requesting...", "pending");
}

function handleAssetStart(data) {
  console.log(
    `Starting asset download: ${data.assetId}, size: ${data.totalSize} bytes, chunks: ${data.totalChunks}`,
  );

  assetStreams.set(data.assetId, {
    assetId: data.assetId,
    totalSize: data.totalSize,
    totalChunks: data.totalChunks,
    chunks: [],
    receivedChunks: 0,
    buffer: new Uint8Array(data.totalSize),
    expectingBinary: false,
    nextChunkIndex: 0,
  });

  updateStatus(
    "asset-status",
    `Downloading (0/${data.totalChunks})`,
    "pending",
  );
}

function handleAssetChunkMetadata(data) {
  const stream = assetStreams.get(data.assetId);
  if (!stream) {
    console.error("Received chunk metadata for unknown asset:", data.assetId);
    return;
  }

  // Store chunk metadata and set flag to expect binary data next
  stream.currentChunkMeta = data;
  stream.expectingBinary = true;

  console.log(
    `Received metadata for chunk ${data.chunkIndex} of ${data.assetId}`,
  );
}

function handleAssetChunkData(arrayBuffer) {
  // Find the stream that is expecting binary data
  let targetStream = null;
  let targetAssetId = null;

  for (const [assetId, stream] of assetStreams) {
    if (stream.expectingBinary) {
      targetStream = stream;
      targetAssetId = assetId;
      break;
    }
  }

  if (!targetStream) {
    console.error("Received binary data but no stream is expecting it");
    return;
  }

  const chunkMeta = targetStream.currentChunkMeta;
  const chunkData = new Uint8Array(arrayBuffer);

  // Copy chunk data into the buffer at the correct offset
  targetStream.buffer.set(chunkData, chunkMeta.offset);
  targetStream.receivedChunks++;

  console.log(
    `Received binary chunk ${chunkMeta.chunkIndex} of ${targetAssetId} (${chunkData.length} bytes)`,
  );

  // Reset binary expectation flag
  targetStream.expectingBinary = false;
  targetStream.currentChunkMeta = null;

  // Update status
  updateStatus(
    "asset-status",
    `Downloading (${targetStream.receivedChunks}/${targetStream.totalChunks})`,
    "pending",
  );
}

function handleAssetComplete(data) {
  const stream = assetStreams.get(data.assetId);
  if (!stream) {
    console.error("Received completion for unknown asset:", data.assetId);
    return;
  }

  console.log(`Asset download complete: ${data.assetId}`);

  // Create blob from buffer
  const blob = new Blob([stream.buffer], { type: "model/gltf-binary" });
  const url = URL.createObjectURL(blob);

  // Load the GLB model
  loadGLBModel(url, data.assetId);

  // Clean up
  assetStreams.delete(data.assetId);
  updateStatus("asset-status", "Loaded", "connected");
}

function loadGLBModel(url, assetId) {
  console.log("Loading GLB model:", assetId);

  gltfLoader.load(
    url,
    (gltf) => {
      console.log("GLB model loaded successfully:", assetId);

      // Remove the old cube
      if (cube) {
        scene.remove(cube);
      }

      // Add the loaded model to the scene
      const model = gltf.scene;
      model.position.set(0, 0, 0);
      scene.add(model);

      // Store reference for animation
      cube = model;

      console.log("Model added to scene");
      URL.revokeObjectURL(url);
    },
    (progress) => {
      console.log("Loading progress:", progress);
    },
    (error) => {
      console.error("Error loading GLB model:", error);
      updateStatus("asset-status", "Load Error", "disconnected");
      URL.revokeObjectURL(url);
    },
  );
}

initThreeJS();
initWebSocket();
